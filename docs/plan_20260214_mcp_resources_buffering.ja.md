# 実装計画書: MCP Resources を活用した画像バッファリングと履歴アクセス

## 1. 目的
現在の「処理後に画像を破棄する」プロトコルをさらに進化させ、LLM のコンテキスト（会話履歴）を消費せずに、必要に応じて過去のフレームへアクセスできる「オンデマンド画像取得」の仕組みを構築する。

## 2. アーキテクチャ概要
- **バッファ**: サーバー側のメモリまたは一時ファイルに、直近 N フレーム分の画像を保持する。
- **リソース提供**: MCP の `Resources` 機能を使用して、各フレームに一意の URI（例: `mcp://video/frame/123.jpg`）を割り当てる。
- **オンデマンド読み込み**: LLM は通知（Notifications）で URI だけを受け取り、詳細な解析が必要な場合のみ、その URI を読みに行く。

---

## 3. 詳細タスク分割

### タスク 1: フレームバッファ・サービスの実装
- [ ] `src/WindowsDesktopUse.Screen` に `FrameBufferService` を作成。
- [ ] 保持する最大フレーム数（例: 100枚）または時間（例: 5分分）を設定可能にする。
- [ ] スレッドセーフな `ConcurrentDictionary<string, byte[]>` で画像を管理。
- [ ] 古いフレームを自動的に削除するクリーンアップロジックの実装。

### タスク 2: リソース URI スキーマの定義
- [ ] フレームを特定するための URI 形式を決定。
    - 形式案: `mcp://video/frames/{sessionId}/{timestamp}.jpg`
- [ ] タイムスタンプや連番から URI を生成するヘルパーメソッドの実装。

### タスク 3: MCP Resource サーバー機能の実装
- [ ] `Program.cs` の MCP サーバー設定にリソースハンドラを追加。
- [ ] **ListResources**: 現在バッファにある全てのフレーム URI を一覧として返す機能を実装。
- [ ] **ReadResource**: 指定された URI に対応する画像をバッファから取り出し、バイナリ形式で LLM に返す機能を実装。

### タスク 4: 既存ツールの統合
- [ ] `watch_video_v2` の通知データに、実データ（base64）の代わりに（または追加で）`resourceUri` を含める。
- [ ] `use_resource: true` オプションを追加し、有効な場合は base64 を送らず URI のみを返すようにする。

### タスク 5: LLM 指示（Prompt）の最適化
- [ ] `_llm_instruction` を更新し、「詳細な視覚解析が必要な場合は `ReadResource` を使用して画像を取得せよ」という指示を追加。
- [ ] リソースの存在期間（TTL）を LLM に伝え、古いリソースへのアクセス失敗を予期させる。

---

## 4. 期待される効果
- **トークン消費の極小化**: 通知（Push）されるデータがテキストのみになるため、100回以上の連続キャプチャでもコンテキストが溢れない。
- **情報の非破壊性**: LLM が「3秒前の画面と今の画面を比較したい」と思った際、過去の URI を参照することで正確な比較が可能になる。
- **レスポンスの高速化**: 巨大な base64 を JSON-RPC で転送する頻度が減り、通信のオーバーヘッドが削減される。
