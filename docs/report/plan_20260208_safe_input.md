# デスクトップ操作のセキュリティ強化と安全な入力実装計画 (2026-02-08)

## 1. 背景と目的

現在の `WindowsDesktopUse.Input` モジュールは、OS の入力キューに直接イベントを送り込む `SendInput` API に依存しています。この方式は汎用性が高い一方で、以下の重大なセキュリティリスクを抱えています。

- **意図しない操作の実行**: AI が `Win + R` や `Ctrl + Alt + Del` などのショートカットを生成し、システム設定の変更や悪意のあるコマンドの実行（RCE）を行う可能性がある。
- **入力の誤爆**: 操作中にユーザーが手動でウィンドウを切り替えた場合、AI の入力が別の（機密性の高い、あるいは管理者権限の）アプリケーションに送られてしまう。
- **コンテキストの欠如**: 座標ベースの操作であるため、AI が「何をクリックしているか」を完全に把握できず、ボタンの押し間違いが発生しやすい。

本計画は、これらのリスクを排除し、AI によるデスクトップ操作を **「安全（セーフティ）」** かつ **「確実（ロバスト）」** なものに再構築することを目的とします。

---

## 2. 基本コンセプト：オブジェクト指向の操作へ

OS 全体への自由な入力を許可するのではなく、**「特定のアプリケーションの、特定の要素に対してのみ、直接操作を指示する」** 方式へと転換します。

### 三原則
1. **Direct Control**: キー入力のシミュレートを避け、API（UI Automation や Win32 メッセージ）で直接値をセットまたは実行する。
2. **Target Isolation**: 操作対象のウィンドウを明示的にロックし、それ以外への干渉を物理的に遮断する。
3. **Strict Filtering**: システム操作に繋がるキー（Win, Alt, Ctrl 等）をコードレベルで完全に禁止する。

---

## 3. 安全な操作のためのガードレール

### 3.1. ウィンドウ・ロックとフォーカス・ガード
- **`set_target_window(hwnd)`**: 操作を開始する前に、AI に対象のウィンドウハンドル (`HWND`) を選択させ、サーバー側で保持します。
- **Foreground Validation**: すべての操作（マウス・キーボード共）の実行直前に、`GetForegroundWindow()` を呼び出します。現在のアクティブウィンドウがロックされた `HWND` と一致しない場合は、操作を拒否してエラーを返します。これにより、予期せぬウィンドウへの入力（誤爆）を 100% 防ぎます。

### 3.2. キーボード操作の厳格な制限
- **禁止キー (Blacklist)**: `Win`, `Alt`, `Ctrl`, `Fn`, `Caps Lock`, `Insert` 等、システムコンテキストを変更するキーを完全に無効化します。
- **許可キー (Whitelist)**: `Tab`, `Enter`, `Arrow Keys`, `Escape`, `Space`, `Backspace`, `Delete` のみに制限します。
- **テキスト送信の分離**: 文字列の入力はキーボードエミュレーションではなく、UI Automation の `ValuePattern` または `WM_SETTEXT` を使用して「直接書き込み」を行います。

---

## 4. 新規ツールセットの定義

既存の `mouse_*`, `keyboard_*` ツールを以下の安全なツール群に置き換えます。

| ツール名 | 実装方式 | 安全な理由 |
| :--- | :--- | :--- |
| **`move_window`** | `SetWindowPos` (Win32) | OS のキー操作を介さず、ウィンドウの位置・サイズを直接変更するため。 |
| **`click_element`** | **UI Automation** | 座標ではなく「ボタン」というオブジェクトを特定して実行するため。 |
| **`set_input_text`** | `ValuePattern.SetValue` / `WM_SETTEXT` | フォーカスに関わらず、指定した入力欄以外には書き込めないため。 |
| **`send_nav_key`** | `SendInput` (制限付き) | 移動用のキー（Tab, Enter 等）のみを許可。ショートカットキーによるシステム操作を防止。 |

---

## 5. 技術的アプローチ

### 5.1. UI Automation (UIA) の採用
.NET の `UIAutomationClient` ライブラリを導入します。
- 座標 (`x, y`) からその場所にある `AutomationElement` を取得。
- 要素の型（Button, Edit, List等）を確認し、適切な Pattern（Invoke, Value, Selection）を適用。

### 5.2. ハイブリッド・テキスト入力
1. **第一候補**: UI Automation の `ValuePattern`。最も安全で確実。
2. **第二候補 (Fallback)**: Win32 の `WM_SETTEXT` メッセージ。標準的な Win32 コントロール用。
3. **最終手段**: セキュリティガードを通過した後の `SendInput`（Unicode入力）。ただし、これはホワイトリスト内のウィンドウがアクティブな場合のみ。

---

## 6. 実施ステップ

### フェーズ 1: 基盤整備
1. `WindowsDesktopUse.Input.csproj` への UI Automation 参照の追加。
2. `InputService` へのウィンドウロック機能と Foreground チェックの実装。

### フェーズ 2: 安全なツールの実装
1. `move_window` ツールの実装。
2. UIA を用いた `click_element` と `set_input_text` のプロトタイプ実装。
3. キー制限フィルタを適用した `send_nav_key` の実装。

### フェーズ 3: 移行と検証
1. 既存ツールの非推奨化（Obsolete 警告）。
2. E2E テストの新しいツールへの書き換え。
3. セキュリティ・ペネトレーション・テスト（AI に禁止されたキーを打たせてみて、ブロックされるか確認）。

## 7. 懸念点と対策
- **UIA の互換性**: ブラウザや独自描画のゲームなど、UIA に対応していないアプリへの対応。
  - **対策**: UIA が効かない場合のみ、強い警告と共に制限付きの座標クリックを許可する「セーフモード外操作」オプションを検討する。
- **Tab キーによる脱出**: Tab 連打でウィンドウ外（タスクバー等）にフォーカスが移るリスク。
  - **対策**: 全ての操作直前に行う Foreground チェックでこれを遮断する。
